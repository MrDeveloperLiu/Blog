#### 锁

> 由于篇幅问题：
>
> 笔者不太想把代码如何使用粘贴来，笔者更希望大家能了解锁的特点，以及会引发的一些问题，如有兴趣大家可自行搜索如何使用



在开始讨论锁时，我们需要知道一个概念：临界区

```
临界区段：一个访问共享资源的程序片断，这些共享资源有无法被多个线程访问的特性
```

> 在iOS开发中的锁主要有两大类
>
> 1、互斥锁：通过将代码切成一个一个的临界区实现，当获取锁失败时，线程处于休眠状态，等待被唤醒
>
> 2、自旋锁：通过反复的检查锁变量是否可用来实现，当获取锁失败时，线程处理忙等待



##### 互斥锁

1、非递归锁：NSLock

```
一般的在使用互斥锁中，要求我们加锁与解锁的操作要成对出现，即：
func test() {
	lock.lock()
	//do sth
	lock.unlock()
}
```

那么由于使用不当，很可能在锁定状态中，又调用了锁定，此时就会造成死锁的问题

2、递归锁：NSRecursiveLock、@synchronized

```
可重入锁
func test() {
	lock.lock()
	test()
	lock.unlock()
}
假如该锁为一般的非递归互斥锁，那么test执行调用自身时，也会出现非递归锁中多次加锁的问题导致死锁
```

3、条件锁：NSConditionLock、NSCondition

```
通过条件变量进行加锁解锁，条件为真时加锁，可根据条件解锁等
```

4、信号量：dispatch_semaphore_t

```
gcd 提供的另一种同步机制
```

5、其他锁：os_unfair_lock、pthread_mutex_t



##### 自旋锁

OSSpinLock

```
自旋锁的代码有可能是如下的实现
//获取锁
while (!lock.enable) {
	//自旋忙等待
}
//获取到锁
do sth..
```

不得不说：

在iOS10以前，关键字`atomic`就是由`OSSpinLock`实现的，故对于优先级不同的线程来说如果形成竞态条件，可能会造成"死锁"的情况

```
那么这里为什么说"死锁"
实际上是这样：
	1、优先级低的线程获取到了自旋锁，同时优先级高的线程继续获取该锁
	2、则由于CPU调度任务的优先级关系，优先级高的线程占用时间片，却获取不到锁，造成优先级高的线程一直处于忙等待；
	3、优先级较低的线程占用不到时间片，却获取了自旋锁，则该线程无法被CPU调度，释放不了锁
则这里就产生了"死锁"问题
```

故：在iOS10.0系统后，系统引入了os_unfair_lock来替代OSSpinLock

```
由于os_unfair_lock会在获取不到锁时的线程进行休眠，而非忙等待，则不会有线程优先级反转的问题存在
```